{"meta":{"title":"new Number(10).toString(16) new Number(254).toString(16)","subtitle":null,"description":null,"author":"Yan Yu","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2015-12-03T09:45:50.000Z","updated":"2016-06-24T07:02:36.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2015-11-19T13:16:21.000Z","updated":"2016-06-24T07:02:36.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ES7和ES8特性.md","slug":"ES7和ES8特性","date":"2017-02-09T04:07:19.000Z","updated":"2017-02-09T04:07:19.000Z","comments":true,"path":"2017/02/09/ES7和ES8特性/","link":"","permalink":"http://yoursite.com/2017/02/09/ES7和ES8特性/","excerpt":"","text":"原文出处：https://node.university/blog/498412/es7-es8 最近我为ES6/ES2015写了一篇博客，并做了一个在线教程。你猜怎么着，TC39（译者注：TC39是Javascript技术进化委员会）已经设计并推进ES8了，因此让我们来搞清楚ES7和ES8（官方说法是ES2016和ES2017）。幸运的是，与ES6相比，ES7和ES8的内容相当少。其中ES7仅仅新增了两个新特性！ ES7新特性 Array.prototype.includes 幂运算符 截止到本文发出（2017年2月），ES8标准仍然没有定稿。但是我们仍然可以学习已天完成的（stage 4）和大部分处于候选阶段（stage 3）的特性（关于stage，可以参考TC39 Process，以及我的课程）。目前已经完成的（stage 4）ES8新特性有： Object.values/Object.entries 字符串 padding Object.getOwnPropertyDescriptors Trailing commas in function parameter lists and calls 异步函数 我并没有把处于stage 3的ES8新特性列出来，如果你有兴趣可以查看从0到3所有的提案。 接下来，让我们看看这些新特性吧。 Array.prototype.includes自从有了Array.prototype.includes，世界变得如此美好。在没有Array.prototype.includes，开发人员使用indexOf（indexOf也是从IE10开始完全支持的，IE9都是部分支持）来判断数组中是否包含某一个值，这其实并不是很合适，甚至有些尴尬的，因为ES6中indexOf返回的是值在数组中的索引，是一个整形数值而非布尔值，如果值并没有在数组中出现，那么则返回-1。开发者如果想使用indexOf来判断数组是否包含该值，还需要写额外的代码需要，而不能直接使用indexOf运算的结果来判断，因为当不包含值时返回的索引-1会被js认为是true，而如果值是在数组的第一位返回的索引0则会被js认为是false。 1234567891011let arr = ['react', 'angular', 'vue']// WRONGif (arr.indexOf('react')) &#123; // 0 -&gt; evaluates to false, definitely as we expected console.log('Can use React') // this line would never be executed&#125;// Correctif (arr.indexOf('react') !== -1) &#123; console.log('Can use React')&#125; 如果觉得对-1的判断有些不优雅，还可以使用位判断符—按位非~。~会对返回的索引做-(index + 1)的处理。0会变成-1，1会变成-2，2会变成-3，而-1会变成0。 123456let arr = ['react', 'angular', 'vue']// Correctif (~arr.indexOf('react')) &#123; console.log('Can use React')&#125; 如果使用ES7的includes，只需要这么写： 123456let arr = ['react', 'angular', 'vue']// Correctif (arr.includes('react')) &#123; console.log('Can use React')&#125; includes还支持String类型 123456let str = 'React Quickly'// Correctif (str.toLowerCase().includes('react')) &#123; // true console.log('Found \"react\"') &#125; 有趣的是，在includes没有成为标准之前，已经有很多JavaScript的库实现了同样的功能，取名为includes或者contains（TC39在取名时，因为不可枚举的原因，没有采用contains） jQuery: $.inArray Underscore.js: _.contains Lodash: _.includes (在3.0版本之前，与Underscore一样使用的是 _.contains，译者注：毕竟Lodash是从Underscore fork出来的) CoffeeScript: in操作符（例子%0A)） Dart: list.contains（例子） includes还能够识别NAN，这是indexOf所不具备的。最后，includes还有第二个可选参数fromIndex，标识从哪个索引开始检索，这将会提升执行性能。 例子 12345678910console.log([1, 2, 3].includes(2)) // === true)console.log([1, 2, 3].includes(4)) // === false)console.log([1, 2, NaN].includes(NaN)) // === true)console.log([1, 2, -0].includes(+0)) // === true)console.log([1, 2, +0].includes(-0)) // === true)console.log(['a', 'b', 'c'].includes('a')) // === true)console.log(['a', 'b', 'c'].includes('a', 1)) // === false) 总而言之，includes简化了我们的开发，这不是很好吗！ 幂运算符幂运算符在3D、VR、SVG或者数据可视化领域的数学运算被广泛应用。在ES6和更早的时候，要进行幂运算，我们可以创建一个递归函数，或者使用Math.power方法。如果你忘了幂运算符是什么，幂运算符就是多个相同的因数相乘，比如7的3次幂，就是7*7*7。 因此在ES6/ES2015中，使用Math.power或者递归来计算幂运算，如下： 123calculateExponent = (base, exponent) =&gt; base*((--exponent&gt;1)?calculateExponent(base, exponent):base)console.log(calculateExponent(7,12) === Math.pow(7,12)) // trueconsole.log(calculateExponent(2,7) === Math.pow(2,7)) // true 在ES7/ES2016中，开发人员可以使用更简短的写法了 1234let a = 7 ** 12let b = 2 ** 7console.log(a === Math.pow(7,12)) // trueconsole.log(b === Math.pow(2,7)) // true 与其他运算符一样，幂运算符也可以使用语法糖来简化写法 123456let a = 7a **= 12let b = 2b **= 7console.log(a === Math.pow(7,12)) // trueconsole.log(b === Math.pow(2,7)) // true 新的ES特性从其他语言（CoffeeScript，Ruby等等）中借鉴了很多，所以不难猜到，其他语言中也会有幂运算符。 Python: x ** y CoffeeScript: x ** y F#: x ** y Ruby: x ** y Perl: x ** y Lua, Basic, MATLAB: x ^ y 对于我个人来说，没有幂运算符并没有感到不便。:)在我15年的JavaScript开发经验中，我从来没有写过任何幂运算，除了在面试或者教程中。那么对于你来说，没有幂运算符是否会造成很大的麻烦？ Object.values/Object.entriesES8/ES2017中增加了两个新方法Object.values和Object.entries，与Object.keys一样，两个方法返回的都是数组。，数组中元素的排序与Object.keys返回数据的排序一致。 Object.values、Object.entries与Object.keys这三个方法，分别返回了对应的key值，value值以及特定格式的键值对数据，并且这些返回时一一对应的。 在ES8/ES2017之前，如果开发者想要遍历对象的自有属性，不得不使用Object.keys先获得自有属性的key值，然后使用obj[key]来得到自有属性的值。 1234let obj = &#123;a: 1, b: 2, c: 3&#125;Object.keys(obj).forEach((key, index)=&gt;&#123; console.log(key, obj[key])&#125;) 或者使用ES6/ES2015的for/of会稍微优雅一些 1234let obj = &#123;a: 1, b: 2, c: 3&#125;for (let key of Object.keys(obj)) &#123; console.log(key, obj[key])&#125; 还可以使用ES5的for/in，不过for/in会遍历对象所有可以枚举的属性（比如定义在prototype中的属性，MDN），而不是自有属性，这将会造成不可预料的问题，比如遍历出了prototype或者toString。 Object.values返回对象自有属性的值组成的数组，可以通过forEach来取得值。 12let obj = &#123;a: 1, b: 2, c: 3&#125;Object.values(obj).forEach(value=&gt;console.log(value)) // 1, 2, 3 或者使用for/of 12345let obj = &#123;a: 1, b: 2, c: 3&#125;for (let value of Object.values(obj)) &#123; console.log(value)&#125;// 1, 2, 3 Object.entries返回对象自有属性的键值对数组组成的二维数组。 123let obj = &#123;a: 1, b: 2, c: 3&#125;JSON.stringify(Object.entries(obj))\"[[\"a\",1],[\"b\",2],[\"c\",3]]\" 我们可以使用ES6/ES2015来提取二维数组中的key和value（可以参考这篇文章或者这个教程）。 12345let obj = &#123;a: 1, b: 2, c: 3&#125;Object.entries(obj).forEach(([key, value]) =&gt; &#123; console.log(`$&#123;key&#125; is $&#123;value&#125;`)&#125;)// a is 1, b is 2, c is 3 你可以猜到，我们可以使用ES6的for/of来遍历Object.entries的返回结果。 12345let obj = &#123;a: 1, b: 2, c: 3&#125;for (let [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125; is $&#123;value&#125;`)&#125;// a is 1, b is 2, c is 3 现在提取value还有键值对更加容易了，Object.values和Object.entries联合for/of（ES6）可以很轻松的遍历对象。 padStart和padEndES8提供了字符串原生APIString.prototype.padStart和String.prototype.padEnd，提供类似left-pad的功能，原生API用起来会更愉快，起码不用担心会被unpublish padStart()返回一个指定长度的字符串，如果原来的字符串长度不够，那么从字符串左侧插入占位符补齐长度。占位符是一个指定的字符串，会一直重复直到字符串长度达到要求。从左侧开始补齐，因为在大多数西语环境中，字符串是从左侧开始的。下面的例子是使用空格来占位： 12console.log('react'.padStart(10).length) // \" react\" is 10console.log('backbone'.padStart(10).length) // \" backbone\" is 10 这个方法在财务领域的开发是非常有用的，可以用来做数值报表的对齐。 123console.log('0.00'.padStart(20)) console.log('10,000.00'.padStart(20)) console.log('250,000.00'.padStart(20)) 上面的运行结果是会得到一个非常优美的在会计领域的报表格式 123 0.00 10,000.00250,000.00 占位符默认是空格，也可以在方法的第二个参数中自己定义，并且占位符可以是任意长度。 12console.log('react'.padStart(10, '_')) // \"_____react\"console.log('backbone'.padStart(10, '*')) // \"**backbone\" 不难猜到padEnd，是从字符串结束的位置，也就是右侧开始插入占位符。与padStart一样，也提供了第二个参数自定义占位符。 12console.log('react'.padEnd(10, ':-)')) // \"react:-):-\" is 10console.log('backbone'.padEnd(10, '*')) // \"backbone**\" is 10 Object.getOwnPropertyDescriptors新的apiObject.getOwnPropertyDescriptors返回对象所有的自有属性，是Object.getOwnPropertyDescriptor(obj, propName)的复数版本，Object.getOwnPropertyDescriptor(obj, propName)只能返回指定自有属性的值。 现在我们面对的是不可变数据编程，这个方法能起到很大的作用（记住，JavaScript是传引用的，不是传值得）。在ES5中，开发者使用Object.assign()来复制数据，Object.assign()只能复制自有属性，而不能复制prototype中的属性，这将很难处理复杂对象或者class属性的。 Object.getOwnPropertyDescriptors可以用来创建一个真正的浅拷贝或者创建一个子类。结合Object.create(prototype, object)来创建浅拷贝，Object.getOwnPropertyDescriptors返回结果作为第二个参数传给Object.create(prototype, object)。（译者注：Object.create(prototype, object)的第一个参数是创建对象的prototype，也可以说是prop，第二个参数用来创建对象的自有属性，也可以说是this属性） 1234Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 或者，我们也可以合并target和source两个对象 1234Object.defineProperties( target, Object.getOwnPropertyDescriptors(source)) 那么什么是descriptor描述符呢？描述符是一个对象，咄！ 好吧好吧，让我们来更深入的了解描述符。在JavaScript中有两种描述符： 数据描述符 访问器描述符 访问器描述符有两个强制属性，get和set，根据名字你也能够猜到是getter方法和setter方法。还有两个可选属性，configurable和enumerable。 12345678let azatsBooks = &#123; books: ['React Quickly'], get latest () &#123; let numberOfBooks = this.books.length if (numberOfBooks == 0) return undefined return this.books[numberOfBooks - 1] &#125;&#125; 上例中的数据描述符是books，执行Object.getOwnPropertyDescriptor(azatsBooks, &#39;books&#39;)得到： 123456Object configurable: true enumerable: true value: Array[1] writable: true __proto__: Object 同样，对于修饰符执行latest，执行Object.getOwnPropertyDescriptor(azatsBooks, &#39;latest&#39;)得到： 123456Object configurable: truee numerable: true get: latest() set: undefined __proto__: Object 下面让我们使用新的api来得到所有修饰符 console.log(Object.getOwnPropertyDescriptors(azatsBooks)) 返回的结果中包含了描述符books和latest 1234567891011121314Object books: Object configurable: true enumerable: true value: Array[1] writable: true __proto__: Object latest: Object configurable: true enumerable: true get: latest() set: undefined __proto__: Object __proto__: Object 在浏览器的控制台中执行，会得到如下面的打印结果 方法参数允许以逗号结束这个是纯粹的语法变化，在ES5中，方法的参数不能以逗号结束。 12345678var f = function(a, b, c, d) &#123; // NO COMMA! // ... console.log(d)&#125;f(1,2,3,'this') 在ES8中，这是被允许的 123456789var f = function(a, b, c, d,) &#123; // COMMA? OK! // ... console.log(d)&#125;f(1,2,3,'this') 其他允许以逗号结束的行为有：数组允许以逗号结束（从ES3开始），对象允许以逗号结束（从ES5开始） 12345678var arr = [1, // Length == 3 2, 3,] // &lt;--- oklet obj = &#123;a: 1, // Only 3 properties b: 2, c: 3,&#125; // &lt;--- ok 并且，这种写法是git-friendly的。 如果你写代码习惯对方法参数换行的话，尤其又是有很多参数的时候，这个改动会对你有很大的帮助。通常都会把参数直接的逗号放在每行的第一位，这样能够提醒开发者这一行与上一行是一个方法的参数，还能提醒开发者逗号不能是最后一位，这样的写法虽然避免了问题，但是一大堆以逗号开头的代码看起来还是很怪异的。现在方法参数允许以逗号结束了，就不会再有这种问题了，开发者可以把逗号放在任何地方，即使是方法参数的最后一位。 异步函数异步函数，或者说async/await大家会更熟悉，类似于Promise，都是用来更简洁的处理异步调用的。因为。。。好吧，因为人类的大脑在进化过程中，并没有进化出并行处理事物的机能。 个人来讲，我并不喜欢promise（译者注：同感）。相比回调，promise显得更加冗长和繁琐，所以我从来不使用promise。幸运的是，在ES8里面，开发者可以使用async关键字来定义一个函数，来实现基于promise的操作。每一个异步函数都返回promise对象。 在ES6中，我们可以使用Promise和Axios来创建一个请求： 123456axios.get(`/q?query=$&#123;query&#125;`) .then(response =&gt; response.data) .then(data =&gt; &#123; this.props.processfetchedData(data) // Defined somewhere else &#125;) .catch(error =&gt; console.log(error)) 任何一个promise库都能够与async/await配合使用，我们使用async/await改造上面的例子，并增加了try/catch来捕获异常 123456789async fetchData(url) =&gt; &#123; try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data this.props.processfetchedData(data) &#125; catch (error) &#123; console.log(error) &#125;&#125; async声明的函数会返回一个Promise对象，因此我们可以继续用promise的方式来处理我们的工作流。 123456789101112async fetchData(query) =&gt; &#123; try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data return data &#125; catch (error) &#123; console.log(error) &#125;&#125;fetchData(query).then(data =&gt; &#123; this.props.processfetchedData(data)&#125;) async/await的工作原来可以参考Babel REPL%20%7B%0A%20%20return%20new%20Promise(resolve%20%3D%3E%20%7B%0A%20%20%20%20setTimeout(()%20%3D%3E%20%7B%0A%20%20%20%20%20%20resolve(%7Bdata%3A%20x%7D)%0A%20%20%20%20%7D%2C%202000)%0A%20%20%7D)%0A%7D%7D%0Alet%20query%20%3D%20’mangos’%0Aasync%20function%20fetchData(query)%20%7B%0A%20%20try%20%7B%0A%20%20%20%20const%20response%20%3D%20await%20axios.get(%60%2Fq%3Fquery%3D%24%7Bquery%7D%60)%0A%20%20%20%20const%20data%20%3D%20response.data%0A%20%20%09return%20data%0A%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20console.log(error)%0A%20%20%7D%0A%7D%0AfetchData(query).then(data%20%3D%3E%20%7B%0A%20%20console.log(data)%0A%7D))，需要注意的是axios是一个mock库，使用setTimeout来模拟异步请求返回。 123456789101112131415161718192021let axios = &#123; // mocks get: function(x) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;data: x&#125;) &#125;, 2000) &#125;)&#125;&#125;let query = 'mangos'async function fetchData(query) &#123; try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data return data &#125; catch (error) &#123; console.log(error) &#125;&#125;fetchData(query).then(data =&gt; &#123; console.log(data) // Got data 2s later... Can use data!&#125;) 使用了async/await，你可以以同步调用的方式来处理异步函数。这种方式更加符合从上向下的阅读习惯，并且结束输出也是从上向下顺序执行的。 总结这或多或少是所有的ES8（尚未完成）和全部的ES7（完成）。如果你使用了Bable、Traceur这类的转换器，那么不用等到浏览器支持，也可以现在就使用这些新特性。ES7和ES8会被编译成ES5的代码，即使是IE9也能够运行这些经过转换的代码。 在使用ES8的特性时，需要小心下面的这些特性，因为这些特性现在虽然处于3阶段，但是可能会被从ES8标准中剔除 Shared Memory and Atomics SIMD.JS - SIMD APIs Function.prototype.toString Lifting Template Literal Restriction global Rest/Spread Properties Asynchronous Iteration import() 你可以在激活提案和完成提案中了解他们的状态。（译者注，在原作者完成这篇文章后Shared Memory and Atomics已经被加入到了完成提案中，也就是进入到了4阶段） PS: 了解ES6/ES2015中的其他新特性，如Promise、箭头函数、let/const，可以阅读我的博客或者查看视频。 PS2: 如果你更喜欢通过视频学习，请进入Node.University的ES6/ES2015课程，并关注即将上线的ES7和ES8课程。（译者注，目前ES7和ES8的课程已经开放了，不过仅针对于付费会员）","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"es7","slug":"es7","permalink":"http://yoursite.com/tags/es7/"},{"name":"es8","slug":"es8","permalink":"http://yoursite.com/tags/es8/"}]},{"title":"JavaScript 2016 调查 — 状态管理工具","slug":"JavaScript-2016-调查-—-状态管理工具","date":"2016-12-07T10:30:24.000Z","updated":"2016-12-07T10:30:24.000Z","comments":true,"path":"2016/12/07/JavaScript-2016-调查-—-状态管理工具/","link":"","permalink":"http://yoursite.com/2016/12/07/JavaScript-2016-调查-—-状态管理工具/","excerpt":"","text":"TL;DR Redux登顶状态管理工具仍然在不断发展 1 状态管理工具调查结果认知 状态管理在JavaScript中是一个新兴的领域，并不是每一个开发人员都需要使用状态管理工具。 如上图，Redux毫无争议是最流行的状态管理工具，是Flux的一种实现，由facebook开发的用来管理React或者其他前端框架的全局状态的工具。87%的用户听说过Redux，这很让人难以置信，毕竟Redux才出了一年，并且Flux还有需要其他实现。 除了Redux之外的，最成熟的框架是mobx也仅有30%的认知度。 兴趣 如上图，开发者对这些状态管理工具都很感兴趣，尤其是Redux，87%的开发者听说过并且想去学习他。鉴于这些状态管理工具两年前还没有出现，这显然是一个快速发展的领域。 开发者对于Redux表现出了极大的兴趣，这给了Redux作者Dan Abramov很大的压力。Dan Abramov认为Redux不是必须的，只有在遇到问题的时候才应该引入Redux，详细可以查看not every app needs it。 满意度 如上图，总体来讲Redux的开发者满意度最高，MobX和Replay满意度中等。我们期待在后续能看到其他竞争者的出现。 如果过一段时间再做调查，在满意度方面出现了一枝独秀的情况，这也不会让人感到惊奇。 如上面的热力图，如我们的语气，Redux与React及React相关的框架搭配使用最多，如React自身、Webpack、Enzyme以及React Native等等。 Mobx与Redux的分布一致，只是相关度更低一些。 推荐资源 Getting Started with Redux，Redux入门 Manage Complex State in React Apps with MobX，在React应用中使用MobX管理复杂状态 2 其他状态管理工具的调查结果 如上图，也许并没有出乎大家的意料，有很多状态管理工具在被使用，其中过半的工具是Flux的实现。然而使用这些工具的开发者人数太低了，Redux已经成为了Flux实现的赢者。另一部分非Flux实现的工具，都是与特定框架绑定使用的，如Vuex。 RxJS、Elm和CycleJS出现在调查榜单是可能是因为开发者觉得他们有趣或者有发展潜力，但是过低的使用人数阻止了他们的发展和扩散。 3 对状态管理工具的满意程度用1-5这5个数字来为你当前使用的状态管理工具来打分。 有趣的是，即使Redux占有绝对优势并且有很高的满意度，但是总体来说用户对自己在使用的状态管理工具并不是很满意，平均得分在3.19，是本次调查中的最低分了。 有可能是因为一些开发者认为Redux需要与React绑定使用，而其实Redux是可以脱离React生态单独使用的。不管怎么说，满意度是否会与使用Redux以及其他工具的人数成正比，这将会是很有趣的结果。 4 结论状态管理工具是一个很有趣的领域，我个人认为调查结果并不能很好的说明当前状态管理工具的现状，我们仍然需要继续调查来丰富我们的揭露。基于我们得到的数据，大部分工具是基于Redux的。 实际上Apollo（Meteor中使用的跨平台GraphQL客户端）的状态管理工具，也是直接在Redux Store上构建的。 Redux周边的工具越来越丰富，如提示工具、开发者工具和继承工具等，这会让我们把Redux加入到Apollo更加容易。我认为越来越多的人会遵循这中在Redux上构建的模式。","categories":[],"tags":[{"name":"JavaScript 2016","slug":"JavaScript-2016","permalink":"http://yoursite.com/tags/JavaScript-2016/"}]},{"title":"JavaScript 2016 调查 — 前端框架","slug":"JavaScript-2016-调查-—-前端框架","date":"2016-12-06T11:33:11.000Z","updated":"2016-12-06T11:33:11.000Z","comments":true,"path":"2016/12/06/JavaScript-2016-调查-—-前端框架/","link":"","permalink":"http://yoursite.com/2016/12/06/JavaScript-2016-调查-—-前端框架/","excerpt":"","text":"原文出处：http://stateofjs.com/2016/frontend/ TL;DR 不要错过ReactVue崛起Angular 2 > Angular 1 主流框架调查结果认知 如上图，除了新框架Vue，其他框架的认知率都超过了97%。 兴趣 认知调查的结果跟预期差不多，但是兴趣调查的结果就有些出人意料了。如上图，Angular2对开发者来说仍然是新的技术，从绝对数量上来讲，1893个开发者希望要学习它。 但是如果从百分比上来看，React无可争议的获胜了。如上图，74%的开发者希望去学习他。 令人惊奇的是，Vue不管从百分比还是从绝对数量上都是第二名。 满意度 如上图，从满意度调查结果来看，92%的开发者对React满意，并表示“会继续使用”。Vue以89%紧随其后，Vue现在越来越流行了，Github上每天超过80次star(数据出自bestof.js)。我认为现在React和Vue已经处于一个地位了，而Angular2前途有些未卜，Angular、Ember、Backbone已经落后了。 如上面的热力图，React是如此的引人注目。使用React的开发者，他们使用的技术栈比其他不适用React的开发者要丰富的做。在React生态中的Redux、Enzyme和React Native这些技术，他们可以配合在一起使用，这是非常有趣的。 有趣的是，虽然Angular用户往往不想使用React，但Angular2的用户对他们的主要竞争对手React更有好感！ 推荐资源 React For Beginners，React初级教程 Up and Running with TypeScript，Angular2教程。 2 其他框架的调查结果 如上图。在做调查之前，我对aurelia并不是很了解，但是我现在对它很清楚了，因为它在调查中甩了“其他”框架几条街。虽然我们无法肯定人们对aurelia有多热爱，但是我可以负责任的说，有很多人在使用它，那么它一定有自己独特的魅力。 排在第二位的是meteor和blaze，Meteor现在已经逐渐发展成全栈了。 剩下的框架可以大致被分为两类： 经典框架：knockout、jquery或者dojo 新进小众框架：cycle、polymer或者mithril 这说明了JavaScript框架真的是百花齐放，而在node出现之前，JavaScript大多是原生js的天下。 3 对当前JavaScrip框架的满意程度用1-5这5个数字来为你当前使用的JavaScript框架来打分。 如上图，开发者对它们选择的框架总体来说非常满意。满意度平均分达到了3.78分，这让我们看到了希望，JavaScript可能正在向好的方向发展。","categories":[],"tags":[{"name":"JavaScript 2016","slug":"JavaScript-2016","permalink":"http://yoursite.com/tags/JavaScript-2016/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Vue2","slug":"Vue2","permalink":"http://yoursite.com/tags/Vue2/"},{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"},{"name":"Angular2","slug":"Angular2","permalink":"http://yoursite.com/tags/Angular2/"}]},{"title":"JavaScript 2016 调查 — JavaScript语言规范","slug":"JavaScript-2016-调查-—-JavaScript语言规范","date":"2016-12-02T08:19:10.000Z","updated":"2016-12-06T11:35:19.000Z","comments":true,"path":"2016/12/02/JavaScript-2016-调查-—-JavaScript语言规范/","link":"","permalink":"http://yoursite.com/2016/12/02/JavaScript-2016-调查-—-JavaScript语言规范/","excerpt":"","text":"原文出处：http://stateofjs.com/2016/flavors/ TL;DR ES6是新的标准CoffeeScript过时了一波新的JavaScript语言规范即将到来 当我们在谈论”JavaScript”的时候，我们并不是在讨论一种语言，而实际上是在讨论一个语言家族。 CoffeeScript已经过时了，ES6，TypeScript和Elm现在正在变得越来越流行。 1 语言规范调查结果认知 如上图，ES6、CoffeeScript和TypeScript表现都很不错，让我惊讶的是TypeScript没有其他两者表现的好。 Elm和ClojureScript表现的差强人意，这也能够理解，毕竟这两种语言有自己独有的生态环境，很难融入到主流中。 兴趣 如上图，很大比例的开发者随波逐流地选择使用ES6，但是其中大部分人(89%)还没有学习过ES6。 TypeScript和Elm，没有很多人使用过这两种语言，但是分别有53%和58%的开发者对它们感兴趣。TypeScript和Elm之所以没有那么多人使用，我才是因为它们很难让所有的开发人员都明白它们的优势在什么地方，尤其是写惯了JavaScript的开发者。 更少的开发者使用过CoffeeScript，并且几乎没有人有计划去学习它。我在考虑要不要写一本12券的CoffeeScript百科全书来纪念它。 满意度 在谈满意度调查之前，我们首先要面对一个问题：有多少开发者用过上述所有的JavaScript语言规范，有多少开发者会再次使用这些语言规范。 如上图，虽然原生JS有很大的用户基础，但是ES6令开发者满意的程度更高，可以很负责任的说，ES6是现在JavaScript主流的语言规范。 TypeScript和Elm也都有很高的满意度，两者大约都是85％。最后，只有17％的开发人员愿意考虑再次使用可怜的CoffeeScript。 如上面的热点图，使用原生JS和CSS的开发者，更偏向于老派的开发框架，如Backbone，甚至不使用任何框架。 另一方面，ES6与React有很强的关系，使用React技术栈的开发者习惯使用ES6。而TypeScript与Angluar2则成双入对。 推荐资源 ES6 For Everyone，学习ES6的高级课程 Up and Running with TypeScript，学习TypeScript的课程。 2 对JavaScript语言规范现状的满意程度用1-5这5个数字来为你当前使用的JavaScript语言规范来打分。 如上图，总体满意度还是很高的，平均分达到了3.96。凭上面的表现，我们很难说这是因为JavaScript现在的改进已经很有效了，或者也不是因为JavaScript可能（仅仅是可能）不再像设计之初那么糟糕了。不管怎么说，这个分数算是一种安慰吧。","categories":[],"tags":[{"name":"JavaScript 2016","slug":"JavaScript-2016","permalink":"http://yoursite.com/tags/JavaScript-2016/"},{"name":"语言规范","slug":"语言规范","permalink":"http://yoursite.com/tags/语言规范/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"JavaScript 2016 调查 — 介绍","slug":"JavaScript-2016-调查-——-介绍","date":"2016-12-02T07:27:03.000Z","updated":"2016-12-13T07:03:32.000Z","comments":true,"path":"2016/12/02/JavaScript-2016-调查-——-介绍/","link":"","permalink":"http://yoursite.com/2016/12/02/JavaScript-2016-调查-——-介绍/","excerpt":"","text":"原文出处：http://stateofjs.com/2016/introduction/ 我们可以提出这样问题：JavaScript是一种现代的、可靠的语言，还是一种臃肿的、过度复杂的语言呢？或者兼具上面两种特性？ 此外，你是否在使用React或者Angular2？你真正需要Webpack吗？这个月推荐的CSS处理方法又是什么样子的呢？ 和你一样，我花了大量的时间在上面那些技术中，但是到了最后我确实很混乱。因此我创建了这个调查，来看看其他人是怎么想的。让我没有想到的是，我在两周内收到了9000份调查结果。 这是一个系列文章，包括介绍和结语一共十四个章节，本文是第一章节介绍。 目录： 介绍 JavaScript语言规范 前端框架 状态管理 API层 全栈框架 测试框架 CSS工具 构建工具 移动框架 特性 看法 编辑器 结论","categories":[],"tags":[{"name":"JavaScript 2016","slug":"JavaScript-2016","permalink":"http://yoursite.com/tags/JavaScript-2016/"}]},{"title":"Git Flow vs Github Flow","slug":"Git-Flow-vs-Github-Flow","date":"2016-09-30T10:47:53.000Z","updated":"2016-09-30T10:59:40.000Z","comments":true,"path":"2016/09/30/Git-Flow-vs-Github-Flow/","link":"","permalink":"http://yoursite.com/2016/09/30/Git-Flow-vs-Github-Flow/","excerpt":"","text":"原文出处：Git Flow vs Github Flow 最近我花了一些时间来学习如何使用GIT更好的来管理项目阅读了很多文章关于使用GIT的文章，想找到一种最好的工作方式能够适用于不同的情况现在GIT工作流分为两种：Git Flow和Github Flow这两种方式都能够帮助你管理项目，优化工作流让我们来看看这两种Flow的区别 ##Git Flow Git Flow的理念是利用不同的分离来管理软件开发过程中的不同各阶段。如果你的软件有“release”这个阶段，那么推荐使用Git Flow。但如果你的软件开发是“快速迭代和交付”的，那么不要使用Git Flow。 Git Flow另一个使用场景是，如果团队中有多个人在开发同一个功能。 Git Flow主要维护的分支： master develop features hotfix release Git Flow工作流程： 一旦完成clone到本地，需要立即从master创建一个develop分支，也就开发分支。（译者注：develop分支是功能的继承分支，用来详细记录项目的开发进程和历史，而master分支则用来存储正式版本的发布历史） 一旦需要开发某个功能的时候，无脑从develop分支中创建一个新的feature分支，也就是功能分支。此时不需要考虑其他人正在开发的代码。 当feature分支开发完并且经过测试后，把feature分支合并到develop分支中，这样能够保证develop分支上的代码总是稳定的。（译者注：此处需要注意，是合并到develop分支，而不是master分支。正如我们上面说的，master分支作为正式发布使用） 当所有功能都开发完成，也即是feature分支全部合并到develop分支（译者注，feature分支可以有很多个，有多人并行开发）。我们需要一个release分支来发布我们的功能。 release分支仅用来测试、修复bug和文档生成等工作，而不能再release分支开发新功能，那是feature分支的工作范围。（译者注：从develop分支中创建release分支，能够让develop分支得到释放，其他人可以继续开发，而不会被发布行为所阻塞。并且release分支能够令发布阶段和版本更加清晰） 最后，当release分支上的工作结束后，准备发布，那么就把release分支 合并到master分支上，并分配一个tag号。 显然，Git Flow看起来有很多步骤，很麻烦，但是这种Flow是最安全的，可以帮你规避掉很多错误和风险。我们可以通过脚本来尽量简化Git Flow的过程。或者通过视化的工具，如SourceTree by Atlassian，来更简单更直观的操作整个Flow。下面一段视频是在SourceTree中操作Git Flow 关于Git Flow，推荐下面两篇文章nvie blog, datasift documentation ##Github Flow 读了上面的文章，你认为Github是工作在Git Flow上吗？当然不是！（译者注：作者对此很惊讶。。。。） 实际上，Github上的代码都是一种持续开发的状态，也就没有所谓的“release”阶段，每一次开发完一个新的功能后，都会立即push代码 Github Flow工作流程的主要概念： master分支永远是可以部署的 从master创建分支，分支的名字是啥可描述的，如new-oauth2-scopes 在本地的分支commit，并且经常性的push 通过pull request合并代码 在代码审核后，可以把代码合并到master中 一旦代码合并到master，那么代码是可以部署的 Github Flow官方介绍提供了一个互动的页面，帮助我们了解什么是Github Flow。 Github Flow是一个轻量的管理项目的工作流，并且小巧和安全，QA团队、小团队或者自由职业者会经常使用Github Flow。 Github Flow有一个很好的博客，由Github的布道士Scott Chacon维护。下面一段视频实在SourceTree中操作Github Flow 我非常希望如果你有好的想法关于Git的，可以在这里随意分享，或者如果有比Git Flow和Github Flow更好的Flow，也可以提出，一起分享。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"},{"name":"gitflow","slug":"gitflow","permalink":"http://yoursite.com/tags/gitflow/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"github flow","slug":"github-flow","permalink":"http://yoursite.com/tags/github-flow/"}]},{"title":"假如javascript有了一个标准库（译文）","slug":"假如javascript有了一个标准库（译文）","date":"2016-04-12T10:02:07.000Z","updated":"2016-06-24T07:02:36.000Z","comments":true,"path":"2016/04/12/假如javascript有了一个标准库（译文）/","link":"","permalink":"http://yoursite.com/2016/04/12/假如javascript有了一个标准库（译文）/","excerpt":"","text":"原文出处：https://medium.com/@thomasfuchs/what-if-we-had-a-great-standard-library-in-javascript-52692342ee3f#.3nmsibtul在过去几年，javascript领域主要集中做了两件事情：1、增加了若干新的功能，也就是发布了ES62、创建了一个巨大的js模块库，也就是npm截止到现在（注：原作者撰写文章时间，2016年3月26日，9:52 上午 东海岸时间 ），npm已经包含了259191个模块想象一下，一个没有图书的图书馆，取而代之的是充满了幸运饼干，并且用线把这些幸运饼干穿起来（译者注：此处的原文是Imagine a library with no books, instead being filled to the gills with fortune cookie fortunes. That are tied with strings to each other.可以理解为当前javascript中充满了各种库、框架、工具等轮子，并且是无序的杂乱无章的）下面一张图用来比喻现在javascript的项目就类似于一张用来跟踪连环杀手的线索强，杂乱无章，仅通过线来维系彼此之间的关系ES6（又叫下一代js）增加了大量的新特性和新功能，如：arrows, classes, enhanced object literals, template strings, destructuring, default + rest + spread, let + const, iterators + for..of, generators, unicode, modules, module loaders, map + set + weakmap + weakset, proxies, symbols, subclassable built-ins, promises, math + number + string + array + object APIs, binary and octal literals, reflect api 和 tail calls。那么，让我们来看看，上面那么多新功能，到底什么才是关键功能和关键点。这些新功能是否能帮助你更容易的码代码，另你的代码运行的更好。我们如何能够在js中使用更加便利和有用的软件？只有癌症细胞时为了增长而增长。——出自Edward Abbey（译者注：爱德华·艾比，上个世纪美国作家，发表过散文集《沙漠独居者》等作品）在npm中，许多包的功能很简单，甚至仅仅只有一行代码。那么开发者为什么要引入这种只有一行的包呢？为什么不自己实现这些简单的功能呢？是因为懒吗？我并不这么认为，而是因为在javascript领域里面，有一个约定俗成的规则：任何功能都是可以被按照模块分割的，细粒度的拆分功能到模块，并且通过类似于金字塔模式的依赖关系把这些模块联系起来。我并不认为一些简洁、短小的模块有问题，我甚至也推出过Micro.js，一个专门用来查找那些短小精练类库的网站。但是，我并不认同把一些本质上并不是很重要的代码片段封装成模块并发布出来的行为这种行为将会带来大量的问题，最直白的例子是：如果一个模块被删除了。chaos quickly spreads（译者注：前一段时间闹的沸沸扬扬的left-pad事件。left-pad是一个很小的模块，功能简单，只有寥寥十几行代码，但是被babel，react－native等多个热门项目引用，开发者因为一些原因删除了npm中的left－pad模块，导致多个重要项目构建失败。）下图是browserify的依赖图谱这实际上不是最主要的问题，作为一个开发人员，你的职责是用最简单的方法去解决问题。最简单这个概念比较模糊，让我们这么定义它：令你的代码正常工作，高效的使用，相对来说易于理解，并且尽可能简洁的实现。构建软件有两种方法，一是令软件简单，这种方式明显没有问题；二是令软件复杂，这种方法是没有明显问题。（译者注：我想起了玉伯评价requirejs和seajs的区别。）出自——C.A.R. Hoare（译者注：托尼·霍尔，出生于英国，计算机博士，曾供职于微软，著名的快排就是他发明的，因在计算机领域出色的贡献，2000年因为其在计算机科学与教育上做出的贡献被封为爵士。）上面吐槽了这么多，让我们来看看上面定义的最简单是否真正是简单的代码正常。是的，现在大部分npm模块是正常工作的，但是一旦你以来的某个模块的开发人员升级模块版本，但是没有遵守semver，那么只能祝你好运了。实际上，这种情况我经常遇到，在我Ruby gems的管理中一次一次的反复出现。而Ruby gems的数量与npm相比简直是小物见大巫高效的使用。这是头一个坑。即使你的代码很优秀，但是要获得你的代码，使用者不得不从一个中央服务器拉取这些代码。这些代码还需要与最新版本保持一致，这就会在开发的时候增加额外的工作。并且在部署的时候，也要考虑仓库down掉了，模块不可用，在发布的补丁出现错误等等。因此你不得不需要一个构建系统去处理这些问题，如使用本地缓存技术等等。本质上，这实际增加了复杂度，而复杂度这是生产率的天敌。相对来说容易理解。每一个你引入的类库或者模块，实际上都创建了一个黑盒环境，你只需要关注输入和输出是否符合你的要求即可。比如这个模块，提供了按照截断字符串并且在结尾处增加”…”的功能。现在你可以亲自review一下这个模块，看看是否可以在一行里面实现这个功能，而不是引用这个模块译者注：我觉得此处想说明的是，有好多模块只是实现了很简单的功能，自己实现可能仅需要一行代码，完全没有必要引入一个模块来解决问题。要知道引入一个模块所带来的问题和风险，大大超过你自己管理这一行代码简洁实现。你会花费多少时间去写一个方法来截断字符串，或者检查数字是否是正数，或者做一个leftpad。你会发现在标准库中有一些很微不足道的功能，你可能不知道或者没有注意过它们，但往往使用这些标准的api会加速开发过程。而引入额外的模块，将会带来很大的困扰。其他人在阅读你的代码时候，想比如标准api，还需要关注引入库的依赖，以及实现。有可能leftpad会被各种不同的方式实现5次。今天的软件很像埃及金字塔的结构，没有完整的结构可言，仅仅是强迫奴隶和动物完成的。出自——Alan Kay（译者注：阿伦·凯，天才计算机大师，他是Smalltalk面向对象编程环境语言的发明人之一，也是面向对象编程思想的创始人之一）C或者其他语言的程序员初次转到javascript，会对一件事情感到很奇怪，其它语言中包含了很多有用的基础方法，而javascript却并没有。比如printf方法，在javascript中就没有的javascript并没有像C语言那样提供一个很大的标准库，而采用了一种叫做“令事情更好”的路线（译者注：原文是“making things better”）。在德语中，是“Eierlegende Wollmilchsau”或者“Egg-laying-wool-milk-pig”，意思是说如果一件事情试图去包括所有的事情，那么是过度的复杂性一定会导致其失败下图中的动物是一个整合了很多种动物从而创造出的四不像如果把全部功能整合并创建一个标准库，并引入到浏览器和javascript运行环境中会怎么样？并且提供第三方语言，仅对javascript做一些微小调整，而令javascript更好。一个标准库能领javascript变得统一并且消除差异，将会令开发人员更容易开发javascript，并且不会再有“去google一个类库”或者“自己写一个功能”这种事情发生。不再需要外引入往外的类库，令代码的部署更加容易。native的方法，性能也会得到保证各种内耗将会大大降低在javascript中建立一套标准库。ES6花费了6年的时间才最终定稿，而浏览器对ES6的支持仍然不好。其实有很多优秀的类库可以借鉴的，如Underscore.js。目前很欣慰看到了一些进展，但是希望能够看到通力合作起来去创建一个真正的底层javascript库。码农复杂的事情变简单，那么将会发生什么呢？ 总结作者评价了现在的javascript的生态环境，列举了npm的很多缺点是npm过于复杂和杂乱无章的依赖，会给开发、维护以及build带来很多问题。作者还发出了疑问，过分的依赖是否是健康的，如尽有几行代码实现简单的功能，是否有必要引入一个模块，这样是不是会造成浪费。最后作者希望能够像其他语言一样，比如C或者PHP等（其实这两个语言做的也不好，但是比javscript好），建立一个统一的javascript库，提供底层的工具和方法，取代大量的依赖或者自己开发代码。但是对现状表示不满意，吐槽了现阶段javascript届的执行能力，ES6的推出花了整整六年时间。","categories":[],"tags":[{"name":"－javascript - node - es6","slug":"－javascript-node-es6","permalink":"http://yoursite.com/tags/－javascript-node-es6/"}]},{"title":"IE9浏览器单个CSS文件样式数量限制的bug","slug":"IE9浏览器单个CSS文件样式数量限制的bug","date":"2016-02-16T09:22:11.000Z","updated":"2016-06-24T07:02:36.000Z","comments":true,"path":"2016/02/16/IE9浏览器单个CSS文件样式数量限制的bug/","link":"","permalink":"http://yoursite.com/2016/02/16/IE9浏览器单个CSS文件样式数量限制的bug/","excerpt":"","text":"起因起源于测试报了一个在IE9浏览器的bug，弹窗的自定义样式失效了，无法正常展现，而开发环境中没有这个问题 分析原因因为开发环境没有这个问题，初步判断可能是由于上线过程中对css的build引起的。 登录线上环境看了一下，也发现同样的样式丢失问题，确认了是css build引起的问题 css build的主要工作是多个css合并成一个，并且压缩。 解决问题首先用CSSHint对build后的css做检查，没有发现能够造成严重错误的致命问题。 后来发现如果删除了css中的一些样式，无论是什么样式，只要达到一定数量，其后面失效的样式就会起效。那么我们怀疑是不是IE9对单个CSS文件的大小、行数或者样式数有限制。 后来查了下，发现了msdn的这片blog Stylesheet Limits in Internet Explorer，发现了IE6-9对单个css文件只能支持到4095个样式，超过的样式会被IE浏览器忽略 我们build后获得的单个css文件中的样式是4118个，所以后面的23个样式在IE9浏览器下失效 p.s.IE10以上的限制就变成65534了 bless 主要用来处理IE浏览器下单个css中样式超过限制的问题，分隔单个css成多个小的css，使用@import连接这些分散的css。 bless还提供了grunt插件grunt-bless 集成到我们的grunt中,Grunkfile.js如下： bless: { css: { options: { logCount: true }, files: { &apos;dist/min/system.min.css&apos;: &apos;dist/min/system.min.css&apos; } } }","categories":[],"tags":[{"name":"兼容性","slug":"兼容性","permalink":"http://yoursite.com/tags/兼容性/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"IE浏览器","slug":"IE浏览器","permalink":"http://yoursite.com/tags/IE浏览器/"}]},{"title":"Github中的badge","slug":"Github中的badge","date":"2016-01-28T06:57:34.000Z","updated":"2016-06-24T07:02:36.000Z","comments":true,"path":"2016/01/28/Github中的badge/","link":"","permalink":"http://yoursite.com/2016/01/28/Github中的badge/","excerpt":"","text":"经常能在Github上看到在README的标题下面，会有一排并行排列的徽章，看起来好厉害的样子。 biz-mock 那么这些徽章是如何生成的，由哪些服务提供的，如何管理你的github项目，统计github项目数据？ 根据获得这些徽章的难易程度把这些徽章做一个排序，难度从易到难 1星难度：取得github权限，直接读取 bithound bithound为你的node项目提供了连续分析和风险识别。从第三方依赖、code review、license等方便持续帮助你监控你的代码质量 使用bithound也很简单，只要使用你的github登录bithound，并授予相应的github权限即可。 登陆后添加你的github项目 bithound会自动根据DEPENDENCY INSIGHTS、CODE INSIGHTS等方面对项目进行分析并计算得分，生成多种徽章。徽章提供了markdown和html两种格式供添加 2星难度：npm统计 npm提供了很多种的统计徽章，如npm版本，license，npm download数等。 相比1星难度，npm统计需要额外配置package.json，并在你npm中publish你的项目。 publish后，调用npm相应的徽章服务接口，就可以生成对应徽章了。我目前用到的几个npm徽章服务接口 1、 npm版本 服务接口：https://img.shields.io/npm/v/yourproject.svg 2、npm license 服务接口：https://img.shields.io/npm/l/yourproject.svg 3、npm download数 服务接口：https://img.shields.io/npm/dt/yourproject.svg 3星难度：单独配置 与2星难度和1星难度相比，这部分徽章需要额外配置自己的配置文件，才能够展现徽章。 travis-ci [] travis-ci是一个分布式在线持续可集成服务，与Github紧密结合，能够自动化构建和测试Github项目，支持主流开发语言：C、JS、PHP、Ruby、Python等 首先需要使用你自己的Github登录travis-ci，并给予travis-ci相应Github操作权限 第二步，在你的Github repository中配置.travis.yml配置文件 .travis.yml doc 上面步骤完成后，travis-ci会在每次提交代码的时候，自动构建和测试你的项目，并给出build结果 travis-ci的徽章提供了html、markdown、RST等多种格式 4星难度：多模块联合配置 coveralls coveralls提供代码覆盖率管理的服务，需要与Vows（bdd测试框架），istanbul（代码覆盖率测试）配合，才能生成徽章。实现过程可以参考：vows-istanbul-coveralls-整合 总结Github上的徽章是一个有趣的功能，甚至会让人上瘾，总是希望能够为自己的项目多增加一些徽章，把README装饰的big满满。 http://shields.io/列出了很多有意思的徽章，也可以在其他repository的README中发现没有见过的徽章，查看README源码就可以知道是如何引用的。","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"}]},{"title":"vows istanbul coveralls 整合","slug":"vows-istanbul-coveralls-整合","date":"2015-12-11T09:50:14.000Z","updated":"2016-06-24T07:02:36.000Z","comments":true,"path":"2015/12/11/vows-istanbul-coveralls-整合/","link":"","permalink":"http://yoursite.com/2015/12/11/vows-istanbul-coveralls-整合/","excerpt":"","text":"经常逛github，会发现好多repo在readme都会有badges，看起来逼格满满。本文将会介绍其中一种表示代码覆盖率的badge—coveralls是如何生成的。 上图中显示了coveralls的样式，98%表示了代码覆盖率达到98%，绿色背景表示当前覆盖率良好。 概念介绍首先要介绍几个相关概念;1、Vows，bdd测试框架2、istanbul，代码覆盖率测试3、coveralls，代码覆盖率管理 VowsVows是运行在node环境下的bdd(behavior driven development)测试框架。 主要用来测试异步行为，能够保证执行的合理顺序。 http://vowsjs.org/ http://yanyu0517.github.io/2015/12/03/Vows-node中的bdd框架/ istanbulistanbul是一个由js开发的代码覆盖率检查工具 支持html、LCOV、Cobertura等多种格式 支持命令行 https://github.com/gotwarlost/istanbul coveralls能够帮助你计算你GITHUB和BITBUCKET中代码仓库的代码覆盖率 针对单个文件计算代码覆盖率 定位到代码中的某一行 整个账户的概况 记录所有提交的代码覆盖率 提醒功能 在任何ci下都可以运行 https://coveralls.io/ coveralls提供了多种运行环境，其中node-coveralls是运行在node环境中的 支持的ci服务：travis-ci, codeship, circleci, jenkins，并且支持lcov代码覆盖率报告 https://github.com/nickmerwin/node-coveralls 工作流通过上面的介绍，可以简单了解到整个工作流是如何运作的： 1、通过vows编写测试代码，也可以使用其他测试框架，如mocha,nodeunit等 2、istanbul计算测试代码的代码覆盖率，并输出lcov格式的数据报告./coverage/lcov.info 3、coveralls管理你的代码仓储，并通过ci介入istanbul输出的lcov，生成代码覆盖率分析 配置及整合vows配置vows配置没有什么特殊的要求，需要注意的一点是，vows测试结束后，一定要process exit，istanbul是监听process退出后，给出代码覆盖率，如果process一直不退出，是得不到代码覆盖率报告的。 我在最开始整合istanbul和vows的时候，就遇到了这样的问题： 我的测试代码中需要启动一个http server，而在vows测试结束后，并没有关闭这个server，istanbul一直无法生成代码覆盖率。 此处还有一个坑爹点需要注意，vows的文档中，并没有关于如何监听case执行完毕的api，作为一个专注于异步测试的测试框架，这实在是不应该。 最后我耗费了一天的时间，翻了源代码还有之前的issue，发现了teardown这个方法，是case执行完毕的回调函数，在自己的batch中实现teardown关闭server。 istanbul全局安装istanbul npm install -g istanbul 整合istanbule和vows，只要执行下面的命令即可 istanbul cover -v --print both -- vows --spec my-test.js 注意，上面命令只能在linux下执行，在windows下执行会报错的，这又是一个坑爹点 在windows下执行需要执行下面的命令 istanbul cover -v --print both -- ./node_modules/vows/bin/vows --spec test/biz-mock-test.js github issue：https://github.com/gotwarlost/istanbul/issues/13 命令成功执行后，首先会在控制台中给出测试脚本的执行结果，随后会给出代码覆盖率，并生成代码覆盖率报告 控制台中输出的代码覆盖率 代码覆盖报告，输出在coverage目录下 /coverage -lcov.info //lcov数据 -coverage.json //覆盖率json数据 -lcov-report/*html //lcov html 目录 lcov-report/*html输出的代码覆盖率 整合到 coverallscoveralls分为两个部分： 网站管理 接入代码覆盖率数据 网站管理访问https://coveralls.io/ 直接使用GITHUB和BITBUCKET登录，授权coveralls读取账户中的repo 添加repo到coveralls 在coveralls网站中添加了repo中，因为没有接入代码覆盖率数据，所以仅能看到添加了的repo，而无法看到代码覆盖率 接入代码覆盖率数据如前面所述，代码覆盖率是由istanbul生成的，标准的lcov格式，放在/coverage/lcov.info中 通过node-coveralls，在ci中自动读取lcov数据，并上传到coveralls网站中 step1： 安装node-coveralls npm install coveralls --save-dev step2： 把vows和istanbul都添加到travis ci中 修改package.json 添加测试脚本 &quot;scripts&quot;: { &quot;test&quot;: &quot;istanbul cover -v --print both -- vows --spec test/biz-mock-test.js&quot; }, 修改.travis.yml 让ci自动执行测试脚本 before_script: - &quot;npm install -g istanbul&quot; script: - &quot;npm test&quot; step3： node-coveralls接入lcov数据 修改.travis.yml after_script: - cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js coveralls查看代码覆盖率提交上面的配置后，travis ci会自动build，运行测试代码，生成代码覆盖率报告，并上传的到coveralls网站。在coveralls即可查看repo的代码覆盖率。 生成coveralls覆盖率badgecoveralls会自动为每一个接入了代码覆盖率数据的repo，生成一个badge，并提供了多种文本格式的链接 MARKDOWN TEXTILE RDOC HTML RST 在github的readme中，添加markdown的链接，即可生成覆盖率badge","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"vows","slug":"vows","permalink":"http://yoursite.com/tags/vows/"},{"name":"istanbul","slug":"istanbul","permalink":"http://yoursite.com/tags/istanbul/"},{"name":"coveralls","slug":"coveralls","permalink":"http://yoursite.com/tags/coveralls/"},{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"},{"name":"badge","slug":"badge","permalink":"http://yoursite.com/tags/badge/"},{"name":"coverage","slug":"coverage","permalink":"http://yoursite.com/tags/coverage/"}]},{"title":"Vows node中的BDD框架","slug":"Vows-node中的bdd框架","date":"2015-12-03T08:42:32.000Z","updated":"2016-06-24T07:02:36.000Z","comments":true,"path":"2015/12/03/Vows-node中的bdd框架/","link":"","permalink":"http://yoursite.com/2015/12/03/Vows-node中的bdd框架/","excerpt":"","text":"Vows是运行在node环境下的bdd(behavior driven development)测试框架。 Vows能够异步测试代码，并且保证测试执行的合理顺序。 下面是一个Vows的例子 // division-by-zero-test.js var vows = require(&apos;vows&apos;), assert = require(&apos;assert&apos;); // Create a Test Suite vows.describe(&apos;Division by Zero&apos;).addBatch({ &apos;when dividing a number by zero&apos;: { topic: function () { return 42 / 0 }, &apos;we get Infinity&apos;: function (topic) { assert.equal (topic, Infinity); } }, &apos;but when dividing zero by zero&apos;: { topic: function () { return 0 / 0 }, &apos;we get a value which&apos;: { &apos;is not a number&apos;: function (topic) { assert.isNaN (topic); }, &apos;is not equal to itself&apos;: function (topic) { assert.notEqual (topic, topic); } } } }).run(); // Run it 运行 $ node division-by-zero-test.js 接下来看一个更复杂的例子 首先假设我们有一个模块叫做the-good-things exports.Strawberry = function () { this.color = &apos;#ff0000&apos;; }; exports.Strawberry.prototype = { isTasty: function () { return true } }; exports.Banana = function () { this.color = &apos;#fff333&apos;; }; exports.Banana.prototype = { peel: function (callback) { process.nextTick(function () { callback(null, new(exports.PeeledBanana)); }); }, peelSync: function () { return new(exports.PeeledBanana) } }; exports.PeeledBanana = function () {}; Vows测试代码： var vows = require(&apos;vows&apos;), assert = require(&apos;assert&apos;); var theGoodThings = require(&apos;./the-good-things&apos;); var Strawberry = theGoodThings.Strawberry, Banana = theGoodThings.Banana, PeeledBanana = theGoodThings.PeeledBanana; vows.describe(&apos;The Good Things&apos;).addBatch({ &apos;A strawberry&apos;: { topic: new(Strawberry), &apos;is red&apos;: function (strawberry) { assert.equal (strawberry.color, &apos;#ff0000&apos;); }, &apos;and tasty&apos;: function (strawberry) { assert.isTrue (strawberry.isTasty()); } }, &apos;A banana&apos;: { topic: new(Banana), &apos;when peeled *synchronously*&apos;: { topic: function (banana) { return banana.peelSync(); }, &apos;returns a `PeeledBanana`&apos;: function (result) { assert.instanceOf (result, PeeledBanana); } }, &apos;when peeled *asynchronously*&apos;: { topic: function (banana) { banana.peel(this.callback); }, &apos;results in a `PeeledBanana`&apos;: function (err, result) { assert.instanceOf (result, PeeledBanana); } } } }).export(module); // Export the Suite 运行 $ vows the-good-things-test.js 安装$ npm install vows 概念介绍为了更好的理解Vows，我们首先对Vows测试中的一些概念进行了解 Test Suitetest suite是Vows中最大的测试单元，按照惯例，每一个文件应该对应应该有一个test suite。test suite是由vows.describe产生的 var suite = vows.describe(&apos;subject&apos;) 其中describe的名字是由文件夹名字决定的 通过addBatch方法，测试用例会被加入到test suite中 suite.addBatch({}); test suite同样支持链式调用，addBatch方法通过链式调用，来实现顺序执行 suite.addBatch({/* run 1st */}).addBatch({/* 2nd */}).addBatch({/* 3rd */}); Batches中包含了contexts，用来描述测试用例 suite.addBatch({ &apos;A context&apos;: {}, &apos;Another context&apos;: {} }); 每一个Batch中的context是完全异步的，无法保证哪个context最先执行完 Contexts中包含了topics和vows，组合在一起构成了测试用例行为 suite.addBatch({ &apos;A context&apos;: { topic: function () {/* Do something async */}, &apos;I am a vow&apos;: function (topic) { /* Test the result of the topic */ } }, &apos;Another context&apos;: {} }); 并且contexts中还可以包含子contexts 子contexts会在其父contexts执行结束后开始执行 总结 Test Suite 是一个对象，包含了零个或者多个batchesbatch是一个字面量对象，是context的容器context是一个对象，包含一个可选的topic，零个或者多个vows，以及零个或者多个子contexttopic可以是值，也可以是方法，执行异步测试代码vow是一个方法，以参数的方式接收topic，并对其执行断言 Suite → Batch* Batch → Context* Context → Topic? Vow* Context* 可以通过下面代码 来形象的了解上述概念 vows.describe(&apos;Array&apos;).addBatch({ // Batch &apos;An array&apos;: { // Context &apos;with 3 elements&apos;: { // Sub-Context topic: [1, 2, 3], // Topic &apos;has a length of 3&apos;: function (topic) { // Vow assert.equal(topic.length, 3); } }, &apos;with zero elements&apos;: { // Sub-Context topic: [], // Topic &apos;has a length of 0&apos;: function (topic) { // Vow assert.equal(topic.length, 0); }, &apos;returns *undefined*, when `pop()`ed&apos;: function (topic) { assert.isUndefined(topic.pop()); } } } }); Topics在vows中，测试对象，topic，测试行为是被分离的 { topic: 42, &apos;should be equal to 42&apos;: function (topic) { assert.equal (topic, 42); } } 在上例中，topic是被单独分离出来，作为参数，传递给vow，在vow通过断言判断topic和预期值 接下来，我们看一下如果topic是方法的话，会如何 { topic: function () { return 42 }, &apos;should be equal to 42&apos;: function (topic) { assert.equal (topic, 42); } } 与topic直接等于42是一样的 一个topic对应两个vow方法 { topic: function () { return 42 }, &apos;should be a number&apos;: function (topic) { assert.isNumber (topic); }, &apos;should be equal to 42&apos;: function (topic) { assert.equal (topic, 42); } } topic的作用域 有可能在子topic中会需要父topic的值 { topic: new(DataStore), &apos;should respond to `get()` and `put()`&apos;: function (store) { assert.isFunction (store.get); assert.isFunction (store.put); }, &apos;calling `get(42)`&apos;: { topic: function (store) { return store.get(42) }, &apos;should return the object with id 42&apos;: function (topic) { assert.equal (topic.id, 42); } } } 在上面的例子中, &#39;calling get(42)&#39; context的topic，通过方法的参数store，得到了父topic，new(DataStore)， 并且vow支持多层topic嵌套，都可以通过子topic方法的参数获得 topic: function (a, /* Parent topic */ b, /* Parent of parent topic */ c /* Parent of parent of parent topic */) {} 通过参数的排列顺序，可以区分父topic的层级，最近的父topic，作为第一个参数 运行Test suite通过run方法，运行test suite vows.describe(&apos;subject&apos;).addBatch({/* ... */}).run(); run方法有一个可选参数，callback，运行结束后的回调函数，并在callback的参数中会得到运行结果 { honored: 145, broken: 4, errored: 1, pending: 0, total: 150, time: 5.491 }; node中运行subject-test.js $ node subject-test.js 结果会被console到控制台 Export test suite 通过export，能够整合多个test suite 当需要export时，仅需要用export来替代run方法，并把test suite export到module 在node环境中，module是全局的 // subject-test.js vows.describe(&apos;subject&apos;).addBatch({/* ... */}).export(module); vows命令运行test uite $ vows subject-test.js 这种方法与上面node中运行subject-test.js是一样的 vows命令还支持批量执行test suite $ vows test/* 将会执行test文件夹下的所有test suite vows命令还支持参数输入，如传入–spec标志位 export还有另外一种方式，可以把vow对象直接传递给exports对象 exports.suite1 = vows.describe(&apos;suite one&apos;); exports.suite2 = vows.describe(&apos;suite two&apos;); 整理一下上面所讲，一个完整的vows测试如下 // subject-test.js // A test suite, describing &apos;subject&apos; vows.describe(&apos;subject&apos;) // Create the suite, describing &apos;subject&apos; .addBatch({}) // Add the 1st batch .addBatch({}) // Add a 2nd batch .addBatch({}) // Add a 3rd batch .export(module); // Export it 运行 vows subject-test.js --spec 异步测试假设，如果我们想测试一个文件是否存在，并且这个文件需要符合某一些标准 因为是异步读取文件，无法在topic中直接return文件信息，那么在vow方法中，也就拿不到正确的文件信息，无法执行测试。 关键就在于，如何等待topic中的异步结束，并把结果传给vow方法 { topic: function () { fs.stat(&apos;~/FILE&apos;, this.callback); }, &apos;can be accessed&apos;: function (err, stat) { assert.isNull (err); // We have no error assert.isObject (stat); // We have a stat object }, &apos;is not empty&apos;: function (err, stat) { assert.isNotZero (stat.size); // The file size is &gt; 0 } } 上面的例子中，关键是this.callback，this.callback在fs.stat执行完毕后被调用，并且this.callback的参数与vow是一一对应的。通过this.callback，就可以使我们把回调函数从异步方法中分离出来 需要注意的是，如果在topic中调用了this.callback，那么topic不要return任何东西。 同样的，如果topic没有return任何东西，那么一定要调用this.callback 事件触发器 Vows同样支持事件触发器，可以在topic中返回一个事件触发器实例，那么vow方法将会被执行，当事件触发器触发error或者success { topic: function () { var emitter = new(events.EventEmitter); fs.stat(&apos;~/FILE&apos;, function (e, res) { if (e) { emitter.emit(&apos;error&apos;, e) } else { emitter.emit(&apos;success&apos;, res) } }); return emitter; }, &apos;can be accessed&apos;: function (err, stat) { assert.isNull (err); // We have no error assert.isObject (stat); // We have a stat object }, &apos;is not empty&apos;: function (err, stat) { assert.isNotZero (stat.size); // The file size is &gt; 0 } } 如上述中，topic中并没有调用this.callback，而是返回了一个事件触发器的实例emitter。 在fs.stat的callback中，根据返回结果，emitter触发error或者success 执行顺序 当多个context嵌套的时候，异步测试的执行顺序如何呢 { topic: function () { fs.stat(&apos;~/FILE&apos;, this.callback); }, &apos;after a successful `fs.stat`&apos;: { topic: function (stat) { fs.open(&apos;~/FILE&apos;, &quot;r&quot;, stat.mode, this.callback); }, &apos;after a successful `fs.open`&apos;: { topic: function (fd, stat) { fs.read(fd, stat.size, 0, &quot;utf8&quot;, this.callback); }, &apos;we can `fs.read` to get the file contents&apos;: function (data) { assert.isString (data); } } } } 上面例子中，是三层context嵌套，有三个topic，这三个topic执行的都是异步方法，并在最深层次的context的vow方法做断言判断。 最外层topic，是读取文件信息，中间层topic打开文件，最深层topic读取文件数据 执行顺序也是最外层topic-&gt;中间层topic-&gt;最深层topic-&gt;最深层vow方法执行断言 并且topic结果，也是从父topic一层一层传给子topic 下面这个例子，是异步测试一些设备 { &apos;/dev/stdout&apos;: { topic: function () { path.exists(&apos;/dev/stdout&apos;, this.callback) }, &apos;exists&apos;: function (result) { assert.isTrue(result) } }, &apos;/dev/tty&apos;: { topic: function () { path.exists(&apos;/dev/tty&apos;, this.callback) }, &apos;exists&apos;: function (result) { assert.isTrue(result) } }, &apos;/dev/null&apos;: { topic: function () { path.exists(&apos;/dev/null&apos;, this.callback) }, &apos;exists&apos;: function (result) { assert.isTrue(result) } } } 上面是多个同级context，异步执行。Vows并不能保证这写context的执行顺序，只会在最后一个I/O操作结束，并执行完assert后退出。 也就是说，对于多层context嵌套，因为有父子关系，Vows会保证context的执行顺序，是从父到子，即使是异步方法 而如果是多个平级context执行，那么Vows无法保证顺序 断言Vows的断言是继承自node的assertion，并对错误报告功能作为更好的改进 推荐使用更能表明测试语义的断言方法，这样能得到更明确的测试结果。 比如下面判断数组的长度 使用assert.equal方法判断数组长度 var ary = [1, 2, 3]; assert.equal(ary.length, 5); 测试结果如下 expected 5, got 3 我们还可以使用assert.lengthOf方法判断数组长度 var ary = [1, 2, 3]; assert.lengthOf(ary, 5); 测试结果如下 expected [1, 2, 3] to have 5 elements 使用assert.lengthOf方法的测试结果，更加明确 Vows的常用断言方法：assert.match, assert.instanceOf, assert.include 和 assert.isEmpty 完整的Vows断言方法，http://vowsjs.org/#reference 宏当我们需要复用topic和vow方法时，我们可以把topic和vow抽象出来 比如，当需要测试http status code，最开始的写法 { topic: function () { client.get(&apos;/resources/42&apos;, this.callback); }, &apos;should respond with a 200 OK&apos;: function (e, res) { assert.equal (res.status, 200); } } 当我们需要测试很多种http status code的时候，我们可以把vow方法抽象出来 function assetStatus(code){ return function(e, res){ assert.equal(res.status, code); } } test suite改写成 { topic: function () { client.get(&apos;/resources/42&apos;, this.callback); }, &apos;should respond with a 200 OK&apos;: assetStatus(200) } 我们已经把vow抽象出来了，是不是可以继续把topic抽象出来？ var api = { get: function (path) { return function () { client.get(path, this.callback); }; } }; test suite再次改写成 { topic: api.get(&apos;/resources/42&apos;), &apos;should respond with a 200 OK&apos;: assetStatus(200) } 经过上面的改造，我们就可以批量测试多个http地址和多个http status code { &apos;GET /&apos;: { topic: api.get(&apos;/&apos;), &apos;should respond with a 200 OK&apos;: assertStatus(200) }, &apos;POST /&apos;: { topic: api.post(&apos;/&apos;), &apos;should respond with a 405 Method not allowed&apos;: assertStatus(405) }, &apos;GET /resources (no api-key)&apos;: { topic: api.get(&apos;/resources&apos;), &apos;should respond with a 403 Forbidden&apos;: assertStatus(403) }, &apos;GET /resources?apikey=af816e859c249fe&apos;: { topic: api.get(&apos;/resources?apikey=af816e859c249fe&apos;), &apos;should return a 200 OK&apos;: assertStatus(200), &apos;should return a list of resources&apos;: function (res) { assert.isArray (res.body); } } } 上面的例子中，topic和vow分别有api.get和assertStatus两个方法生成的，接下来，我们试着整合topic和vow在一个方法 // // Send a request and check the response status. // function respondsWith(status) { var context = { topic: function () { // Get the current context&apos;s name, such as &quot;POST /&quot; // and split it at the space. var req = this.context.name.split(/ +/), // [&quot;POST&quot;, &quot;/&quot;] method = req[0].toLowerCase(), // &quot;post&quot; path = req[1]; // &quot;/&quot; // Perform the contextual client request, // with the above method and path. client[method](path, this.callback); } }; // Create and assign the vow to the context. // The description is generated from the expected status code // and status name, from node&apos;s http module. context[&apos;should respond with a &apos; + status + &apos; &apos; + http.STATUS_CODES[status]] = assertStatus(status); return context; } 上面的例子中，respondsWith方法，用来生成一个context 在context中，topic，是根据this.context（这是因为之前我们说过context是一个字面量对象）来决定如何调用的。 而vow则通过context[&#39;should respond with a &#39; + status + &#39; &#39; + http.STATUS_CODES[status]] = assertStatus(status);设置 最后return context test suite： { &apos;GET /&apos;: respondsWith(200), &apos;POST /&apos;: respondsWith(405), &apos;GET /resources (no key)&apos;: respondsWith(403) } 测试结果： GET / ✓ should respond with a 200 OK POST / ✓ should respond with a 405 Method Not Allowed GET /resources (no key) ✓ should respond with a 403 Forbidden teardown在vows的官方文档中，并没有关于如果batch或者context执行完毕后，如何通知调用者。 这就意味着，如果我在测试代码中，打开了一个数据库连接或者http server，那么在测试结束后，我无法断开数据库连接，或者关闭http server。 这样node的process就不会退出。 process如果process不退出将会很麻烦，如： 集成到ci，那么如果process不退出，ci的build是不会结束的，这样就会永远得不到build结果。 与istanbul这种代码覆盖率测试框架集成，代码覆盖率报告要等到process退出后才能汇总得到，所以如果process不退出的话，是一直得不到代码覆盖率报告的 這对于一个专注于异步测试的框架，是很不应该的。 在耗费了一天的时候阅读源代码和翻阅issue后，发现了teardown这个回调函数。 teardown会在batch和context执行完毕后，被触发。所以我们可以把需要在测试结束后的操作，在batch或者context的teardown中实现 batch和context实现teardown vows.describe(&apos;Array&apos;).addBatch({ // Batch &apos;An array&apos;: { // Context &apos;with 3 elements&apos;: { // Sub-Context topic: [1, 2, 3], // Topic &apos;has a length of 3&apos;: function (topic) { // Vow assert.equal(topic.length, 3); }, teardown: function(){ //将会被触发，当&apos;with 3 elements&apos; context结束 } }, &apos;with zero elements&apos;: { // Sub-Context topic: [], // Topic &apos;has a length of 0&apos;: function (topic) { // Vow assert.equal(topic.length, 0); }, &apos;returns *undefined*, when `pop()`ed&apos;: function (topic) { assert.isUndefined(topic.pop()); } }, teardown: function(){ //将会被触发，当&apos;An array&apos; context结束 } }, teardown: function(){ //会被触发，当Batch结束 } }); 文档运行vows [FILE, ...] [options] 运行指定test suite $ vows test-1.js test-2.js $ vows tests/* 运行所有test suite $ vows 查看模式 $ vows -w $ vows --watch 运行参数-v, --verbose Verbose mode -w, --watch Watch mode -m STRING String matching: Only run tests with STRING in their title -r REGEXP Regexp matching: Only run tests with REGEXP in their title --json Use JSON reporter --spec Use Spec reporter --dot-matrix Use Dot-Matrix reporter --version Show version -s, --silent Don&apos;t report --help Show help 断言方法equality assert.equal (4, 4); assert.strictEqual (4 &gt; 2, true); assert.notEqual (4, 2); assert.notStrictEqual (1, true); assert.deepEqual ([4, 2], [4, 2]); assert.notDeepEqual ([4, 2], [2, 4]); assert.epsilon (1e-5, 0.1 + 0.2, 0.3); type assert.isFunction (function () {}); assert.isObject ({goo:true}); assert.isString (&apos;goo&apos;); assert.isArray ([4, 2]); assert.isNumber (42); assert.isBoolean (true); assert.typeOf (42, &apos;number&apos;); assert.instanceOf ([], Array); truth assert.isTrue (true); assert.isFalse (false); null, undefined, NaN assert.isNull (null); assert.isNotNull (undefined); assert.isUndefined (&apos;goo&apos;[9]); assert.isNaN (0/0); inclusion assert.include ([4, 2, 0], 2); assert.include ({goo:true}, &apos;goo&apos;); assert.include (&apos;goo&apos;, &apos;o&apos;); regexp matching assert.match (&apos;hello&apos;, /^[a-z]+/); length assert.lengthOf ([4, 2, 0], 3); assert.lengthOf (&apos;goo&apos;, 3); emptiness assert.isEmpty ([]); assert.isEmpty ({}); assert.isEmpty (&quot;&quot;); exceptions assert.throws(function () { x + x }, ReferenceError); assert.doesNotThrow(function () { 1 + 1 }, Error);","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"}]},{"title":"前端奇技淫巧(持续更新中)","slug":"前端奇技淫巧-持续更新中","date":"2015-11-09T08:43:44.000Z","updated":"2016-06-24T07:02:36.000Z","comments":true,"path":"2015/11/09/前端奇技淫巧-持续更新中/","link":"","permalink":"http://yoursite.com/2015/11/09/前端奇技淫巧-持续更新中/","excerpt":"","text":"js日期转数值var d = +new Date(); 类数组对象转数组var arr = [].slice.call(arguments) 交换值a= [b, b=a][0]; 快速取数组最大和最小值Math.max.apply(Math, [1,2,3]) //3 Math.min.apply(Math, [1,2,3]) //1 条件判断var a = b &amp;&amp; 1; //相当于 if (b) { a = 1; } else { a = b; } var a = b || 1; //相当于 if (b) { a = b; } else { a = 1; } 位运算符实现开关var toggle; toggle ^= 1; // toggle = 1 toggle ^= 1; // toggle = 0 toggle ^= 1; // toggle = 1 位运算符立即执行匿名函数~function(){}() 等价于 (function(){})() 生成中一定范围内的随机数return Math.floor(Math.random() * (max - min + 1)) + min; 生成从0到指定值的数字数组function numbersArray(max) { var numbersArray = []; for( var i=1; numbersArray.push(i++) &lt; max;); return numbersArray } 生成随机的字母数字function generateRandomAlphaNum(len) { var rdmString = &quot;&quot;; for( ; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len); } 去空格String.prototype.trim = function(){ return this.replace(/^\\s+|\\s+$/g, &quot;&quot;); }; 数组合并var array1 = [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458]; var array2 = [&quot;Doe&quot; , 555 , 100]; Array.prototype.push.apply(array1, array2); /* array1 值为 [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458 , &quot;Doe&quot; , 555 , 100] */ 验证是否为数字function isNumber(n){ return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n); } 验证是否为数组function isArray(obj){ return Object.prototype.toString.call(obj) === &apos;[object Array]&apos; ; } 逗号操作符var a = 0; var b = ( a++, 99 ); console.log(a); // a will be equal to 1 console.log(b); // b is equal to 99 for循环性能提升for (var i = 0, len = arrayNumbers.length; i &lt; len; i++) { 比 for (var i = 0; i &lt; arrayNumbers.length; i++) 因为第一种，i和len都只在循环开始的时候声明一次 switch的另类写法function getCategory(age) { var category = &quot;&quot;; switch (true) { case isNaN(age): category = &quot;not an age&quot;; break; case (age &gt;= 50): category = &quot;Old&quot;; break; case (age &lt;= 20): category = &quot;Baby&quot;; break; default: category = &quot;Young&quot;; break; }; return category; } getCategory(5); // 将返回 &quot;Baby&quot; 不要在循环内部试用try-catchtry-catch在catch部分在执行时会将一场付给一个变量，这个变量将会构建成一个运行时作用域的新的变量，导致循环无法退出，内存泄露 正确的做法，应该是try-catch包裹住循环 css","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"MockServer的一些思考","slug":"MockServer的一些思考","date":"2015-11-05T08:33:55.000Z","updated":"2016-06-24T07:02:36.000Z","comments":true,"path":"2015/11/05/MockServer的一些思考/","link":"","permalink":"http://yoursite.com/2015/11/05/MockServer的一些思考/","excerpt":"","text":"前一阵对整个系统实施了前后端分离改造，使得前端完全脱离后端服务，通过node http server便可以启动整个系统。也正是因为完全脱离了对后端，那么就需要一个mock server来模拟数据。 mock数据源种类mock server纯粹来看，就是能够为指定接口提供数据（无论这个数据时模拟的随机数据或者是真实的接口数据），那么最主要需要考虑的就是，mock server中的数据是从何方取得的。 之前系统中的mock server是通过一个struts的filter来实现的，在filter中拦截所有.action的请求，根据action名称，查询对应的mock数据，静态文件是以.json结尾的json格式文件。 现在前后端分离后，由于不需要后端服务，所以必然这个filter也无法使用，但是前期积累的mock数据json文件可以为新的mock server服务，这就行程了我们第一个mock数据源，静态文件数据源 有了上面的静态文件，如果静态文件足够丰富并且有相应的数据更新同步机制，那么其实已经可以满足对mock数据的要求了。但正是因为静态文件是由人工维护，也就是说是由开发人员逐一建立和更新的，所以并不完美。那么问题来了，我们需要什么样的数据源呢？ 1.稳定，随时可以调用 2.完备，匹配各种action 3.正确，数据合理，符合业务逻辑 除了上面提到的静态文件数据源，还有其他数据源可供选择 随机数据源，由mock模板生成的随机数据。符合稳定、完备，但是并不正确 qa环境数据源，由公司qa维护的数据源，主要用于qa测试使用。这类数据从理论上应该是相对完备，并且符合逻辑。但仅仅是从理论上来讲，起码本司的qa环境长期没有数据，更何况还有好多小公司没有qa。。。。。符合正确，但是并不稳定和完备。不过使用qa环境数据源能够复现qa环境bug。 生产环境（线上）数据源，直接请求线上接口，获得的数据符合了上述3点（如果不符合的话，程序员就要倒霉了，线上故障啊） 如何获得mock数据源1.静态文件数据源 如之前介绍，静态文件数据源可以使用之前积累的静态文件数据，只要适配静态文件数据格式即可。随着系统功能越来越复杂，接口增多，毕然导致静态文件数据原来越多，可维护性越来越来差，依靠人工创建、更新，可靠性也无法保证。 针对上述的问题，可以把人工维护静态文件的工作转托给静态数据更新服务来执行，每次mock请求后（或者定时）对静态文件做更新。 2.随机数据源 根据模板随机产生json或者jsonp数据，可以直接在浏览器中运行生成随机数据，或者在node端生成随机数据。 mockJson http://experiments.mennovanslooten.nl/2010/mockjson mock.js http://mockjs.com/ 3.qa环境数据源 qa环境数据源即直接访问qa环境接口，模拟登陆之后直接访问即可 此处由于我们的统一用户中心没有对外提供直接登录接口，导致不得不一步一步去模拟登陆，浪费了好多时间。因为涉及到系统安全问题（其实注册个账号，有点耐心，自己也是能拔出来的），具体如何实现就不表述了，每家公司的也都不同，不具有通用性 4.生产环境（线上）数据源 生产环境（线上）数据源即直接访问线上接口，因为真实环境中，实施登陆是需要判断验证码的，因此如果想实现自动化登陆，那么就需要对验证码图片做图像处理和分析，有点蛋疼。其实如果直接使用cookie，就可以绕过登陆，请求线上接口数据 具体步骤： 1）首先登陆线上系统 2）随便找一个action，复制其中的cookie 3）在mockserver中为生产环境（线上）数据源配置cookie 4）访问action即可 mock数据源组合使用首先对上面这4种数据源排列一个优先级 生产环境（线上）数据源 &gt; qa环境数据源 &gt; 静态文件 &gt; 随机数据源 数据源可单独使用，可混合使用 在真实使用中，由于随机数据源的随机性太大，只能舍弃不用 根据我们开发的需求，经过反复的尝试，最后我们设置了三种数据源的组合方法， 0指使用本地静态数据源,即便是enable=false 1指使用如下环境数据源， 2指优先使用本地静态数据源中enabled=true的数据, 如果enabled=false,那么去获取如下环境数据源 在方法1和方法2中，环境数据包括qa环境和线上环境 系统搭建基础环境：node web框架：express mockserver自身是用不到express的，只是作为spa后端应用的一部分存在 在express中，对’/*.action’过滤，根据配置，返回结果指向不同数据源 系统架构图如下： 总结优点： 1.不需要改动任何代码，对开发人员无感知 2.能够提供多种数据源 3.node服务不依赖后端 缺点: 1.被整合在spa后端应用中，作为http代理的效果更佳，可以单独部署 2.对上传和下载这种form表单提交的action没有做处理 3.在qa环境中，有的action返回系统忙碌，需要与后端一起排查问题","categories":[],"tags":[{"name":"工作实践","slug":"工作实践","permalink":"http://yoursite.com/tags/工作实践/"}]},{"title":"npm和bower的区别","slug":"npm和bower的区别","date":"2015-10-15T12:20:13.000Z","updated":"2016-06-24T07:02:36.000Z","comments":true,"path":"2015/10/15/npm和bower的区别/","link":"","permalink":"http://yoursite.com/2015/10/15/npm和bower的区别/","excerpt":"","text":"npm和bowernpm和bower都是用来发布模块，管理模块依赖的平台。主要区别如下： 管理模块的区别npm主要用来管理node模块，对模块的格式是有要求的，CommonJS。而bower对模块的格式并没有严格的规定，甚至与npm有自己的模块代码存储仓库不同，bower不会存储任何模块代码，而是依赖github来管理这就决定了npm主要用来管理运行在node环境中的代码，而bower可以check任何代码下来，包括amd，cmd，CommonJS等，所以bower更适合浏览器端。（此处提一下，有人认为凭借browserify，npm也能成为一个很好的浏览器端模块管理工具） 管理依赖的区别npm的依赖是纵深的树结构依赖，而bower是采用的扁平化结构依赖。具体来说，npm在管理依赖的时候，会为每一个模块都建立一个依赖树，每一个模块是独立的，形成了一个孤岛，依赖不会共享。当每一个模块check的时候会下载他所需要的所有依赖，如下图可以看到，上图中的grunt-contrib-less模块的依赖结构，一颗很深的树，有时候这种依赖树甚至会超过window对于文件路径的字符串长度限制（这种反人类的设计，完全没有考虑windows用户的感受）而bower对于依赖的管理，是横向的扁平化结构，每一个模块的依赖，与该模块都是平级的，也就是说，一个模块无论他的依赖多么复杂，对于bower来说，都是一层目录结构。这种结构，使得多个模块可以共享一个依赖，如下图上图中，backbone依赖了underscore，而backbone和underscore是同层级的（同一个文件夹目录下）。不难发现，这种方式更符合浏览器端开发的静态文件目录结构。那么问题来了，这种扁平化操作，如果发生了依赖冲突如何处理，怎么管理不同版本的模块呢？bower给出的处理方式是给出冲突提示，并让用户去选择，下图中，我目前安装了backbone，根据backbone的bower.json中的定义，underscore的版本是1.8.3。当我要安装一个低版本underscore 1.4.1的时候，由于不符合bower.json中&gt;=1.7.0的版本定义，bower会在安装的时候给出提示我选择了1，那么bower会安装1.4.1的版本，之前的1.8.3会删除掉。此时backbone的某些功能由于underscore版本过低是无法使用的关于spm阿里出的类似于npm的模块管理工具，格式是cmd格式，需要与seajs配合使用目前已经基本被阿里所放弃不建议使用component首先说明，没有用过，看同事用过，没有模块代码仓库，都是直接从github上check代码路径采用githubusername/project的格式，很怪异总结npm适合与在node环境中使用，比如build一下代码，搭个http serverbower更适合在浏览器端开发中使用，可以很方便的管理代码","categories":[],"tags":[{"name":"包管理工具","slug":"包管理工具","permalink":"http://yoursite.com/tags/包管理工具/"}]}]}